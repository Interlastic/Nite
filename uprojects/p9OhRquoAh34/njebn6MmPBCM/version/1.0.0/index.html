<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Metro - Track Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        #stats {
            font-size: 14px;
            color: #333;
        }
        
        #stats div {
            margin: 4px 0;
        }
        
        #lineSelector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .line-btn {
            width: 36px;
            height: 36px;
            border: 3px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .line-btn:hover {
            transform: scale(1.1);
        }
        
        .line-btn.active {
            border-color: #333;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .line-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 8px;
        }
        
        .ctrl-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .ctrl-btn:hover {
            background: #fff;
            transform: translateY(-2px);
        }
        
        #help {
            position: absolute;
            top: 10px;
            right: 10px;
            max-width: 320px;
        }
        
        #help h3 {
            margin-bottom: 8px;
            color: #333;
        }
        
        #help ul {
            padding-left: 20px;
            font-size: 13px;
            color: #555;
        }
        
        #help li {
            margin: 4px 0;
        }
        
        #zoomControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            font-size: 20px;
            font-weight: bold;
        }
        
        #zoomLevel {
            text-align: center;
            font-size: 12px;
            color: #666;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px;
            border-radius: 4px;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            padding: 30px 50px;
            border-radius: 12px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        
        #gameOver h2 {
            color: #e74c3c;
            margin-bottom: 15px;
        }
        
        #gameOver p {
            color: #555;
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div class="panel" id="stats">
                <div><strong>‚è± Time:</strong> <span id="time">0:00</span></div>
                <div><strong>üë• Passengers:</strong> <span id="passengers">0</span></div>
                <div><strong>üöá Lines:</strong> <span id="linesCount">0</span>/4</div>
            </div>
            
            <div class="panel">
                <div style="margin-bottom: 8px; font-weight: bold; color: #333;">Select Line:</div>
                <div id="lineSelector"></div>
            </div>
        </div>
        
        <div id="controls">
            <button class="ctrl-btn" onclick="game.pause()">‚è∏ Pause</button>
            <button class="ctrl-btn" onclick="game.resetView()">üéØ Reset View</button>
            <button class="ctrl-btn" onclick="game.clearLine()">üóë Clear Line</button>
            <button class="ctrl-btn" onclick="game.newGame()">üîÑ New Game</button>
        </div>
        
        <div id="help" class="panel">
            <h3>üìñ Track Logic</h3>
            <ul>
                <li><strong>Start:</strong> Click a station to start a line</li>
                <li><strong>Extend:</strong> Click another station to connect</li>
                <li><strong>Continue:</strong> Click more stations to extend</li>
                <li><strong>Overlap:</strong> Lines offset automatically when crossing</li>
                <li><strong>Zoom:</strong> Scroll wheel or +/- buttons</li>
                <li><strong>Pan:</strong> Drag with right-click or middle-click</li>
            </ul>
        </div>
        
        <div id="zoomControls">
            <button class="ctrl-btn zoom-btn" onclick="game.zoomIn()">+</button>
            <div id="zoomLevel">100%</div>
            <button class="ctrl-btn zoom-btn" onclick="game.zoomOut()">‚àí</button>
        </div>
        
        <div id="tooltip"></div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>A station became too crowded!</p>
            <p><strong>Final Score:</strong> <span id="finalScore">0</span> passengers</p>
            <button class="ctrl-btn" onclick="game.newGame()" style="margin-top: 15px;">Play Again</button>
        </div>
    </div>
    
    <script>
        const LINE_COLORS = [
            '#e74c3c', // Red
            '#3498db', // Blue
            '#2ecc71', // Green
            '#f39c12', // Orange
            '#9b59b6', // Purple
            '#1abc9c', // Teal
        ];
        
        const STATION_SHAPES = ['circle', 'triangle', 'square', 'diamond', 'pentagon', 'star'];
        const MAX_PASSENGERS = 8;
        const SPAWN_INTERVAL = 2000;
        const PASSENGER_INTERVAL = 3000;
        
        class Station {
            constructor(x, y, shape) {
                this.x = x;
                this.y = y;
                this.shape = shape;
                this.passengers = [];
                this.connections = new Set();
                this.id = Math.random().toString(36).substr(2, 9);
            }
            
            addPassenger(destination) {
                if (this.passengers.length < MAX_PASSENGERS) {
                    this.passengers.push(destination);
                    return true;
                }
                return false;
            }
            
            removePassenger(destination) {
                const idx = this.passengers.findIndex(p => p === destination);
                if (idx !== -1) {
                    this.passengers.splice(idx, 1);
                    return true;
                }
                return false;
            }
            
            isOvercrowded() {
                return this.passengers.length >= MAX_PASSENGERS;
            }
        }
        
        class Line {
            constructor(color, id) {
                this.color = color;
                this.id = id;
                this.stations = [];
                this.trains = [];
            }
            
            addStation(station) {
                if (!this.stations.includes(station)) {
                    this.stations.push(station);
                    station.connections.add(this.id);
                    return true;
                }
                return false;
            }
            
            removeStation(station) {
                const idx = this.stations.indexOf(station);
                if (idx !== -1) {
                    this.stations.splice(idx, 1);
                    station.connections.delete(this.id);
                }
            }
        }
        
        class Train {
            constructor(line) {
                this.line = line;
                this.currentStationIndex = 0;
                this.progress = 0;
                this.direction = 1;
                this.passengers = [];
                this.capacity = 6;
            }
            
            update(dt) {
                if (this.line.stations.length < 2) return;
                
                this.progress += dt * 0.5; // Speed
                
                if (this.progress >= 1) {
                    this.progress = 0;
                    this.currentStationIndex += this.direction;
                    
                    // Reverse at ends
                    if (this.currentStationIndex >= this.line.stations.length - 1) {
                        this.direction = -1;
                        this.currentStationIndex = this.line.stations.length - 1;
                    } else if (this.currentStationIndex <= 0) {
                        this.direction = 1;
                        this.currentStationIndex = 0;
                    }
                    
                    // Handle passengers at station
                    this.handleStation();
                }
            }
            
            handleStation() {
                const station = this.line.stations[this.currentStationIndex];
                if (!station) return;
                
                // Drop off passengers
                this.passengers = this.passengers.filter(dest => {
                    if (dest === station.shape) {
                        game.passengersDelivered++;
                        return false;
                    }
                    return true;
                });
                
                // Pick up passengers
                const availableSpace = this.capacity - this.passengers.length;
                for (let i = 0; i < availableSpace && station.passengers.length > 0;) {
                    const passenger = station.passengers.shift();
                    // Check if this line can reach the destination
                    if (this.canReachDestination(passenger, station)) {
                        this.passengers.push(passenger);
                    } else {
                        station.passengers.push(passenger);
                        break;
                    }
                    i++;
                }
            }
            
            canReachDestination(destination, currentStation) {
                return this.line.stations.some(s => s.shape === destination);
            }
            
            getPosition() {
                if (this.line.stations.length < 2) return null;
                
                const from = this.line.stations[this.currentStationIndex];
                const toIdx = this.currentStationIndex + this.direction;
                const to = this.line.stations[Math.min(Math.max(toIdx, 0), this.line.stations.length - 1)];
                
                if (!from || !to) return null;
                
                return {
                    x: from.x + (to.x - from.x) * this.progress,
                    y: from.y + (to.y - from.y) * this.progress
                };
            }
        }
        
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.stations = [];
                this.lines = [];
                this.trains = [];
                
                this.selectedLine = null;
                this.currentLine = null;
                this.drawingLine = false;
                this.tempLine = null;
                
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                
                this.time = 0;
                this.passengersDelivered = 0;
                this.isPaused = false;
                this.isGameOver = false;
                
                this.lastSpawn = 0;
                this.lastPassenger = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.initUI();
                this.newGame();
                
                this.lastTime = performance.now();
                this.animate();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }
            
            setupEventListeners() {
                // Mouse events for track drawing
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }
            
            initUI() {
                const selector = document.getElementById('lineSelector');
                selector.innerHTML = '';
                
                LINE_COLORS.forEach((color, i) => {
                    const btn = document.createElement('button');
                    btn.className = 'line-btn';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => this.selectLine(i);
                    btn.id = `line-btn-${i}`;
                    selector.appendChild(btn);
                });
            }
            
            selectLine(index) {
                this.selectedLine = index;
                
                // Find or create line
                this.currentLine = this.lines.find(l => l.id === index);
                if (!this.currentLine) {
                    this.currentLine = new Line(LINE_COLORS[index], index);
                    this.lines.push(this.currentLine);
                    // Add a train
                    const train = new Train(this.currentLine);
                    this.trains.push(train);
                }
                
                // Update UI
                document.querySelectorAll('.line-btn').forEach((btn, i) => {
                    btn.classList.toggle('active', i === index);
                });
            }
            
            handleMouseDown(e) {
                const pos = this.screenToWorld(e.clientX, e.clientY);
                
                // Right click or middle click for panning
                if (e.button === 1 || e.button === 2) {
                    this.isDragging = true;
                    this.dragStart = { x: e.clientX - this.offsetX, y: e.clientY - this.offsetY };
                    return;
                }
                
                // Left click for track drawing
                if (e.button === 0 && this.selectedLine !== null) {
                    const station = this.findStationAt(pos.x, pos.y);
                    
                    if (station) {
                        if (!this.drawingLine) {
                            // Start new line or extend existing
                            this.drawingLine = true;
                            this.currentLine.addStation(station);
                            this.tempLine = { from: station, to: null };
                        } else {
                            // Add station to line
                            this.currentLine.addStation(station);
                            this.tempLine.from = station;
                        }
                    }
                }
            }
            
            handleMouseMove(e) {
                if (this.isDragging) {
                    this.offsetX = e.clientX - this.dragStart.x;
                    this.offsetY = e.clientY - this.dragStart.y;
                    return;
                }
                
                if (this.drawingLine && this.tempLine) {
                    const pos = this.screenToWorld(e.clientX, e.clientY);
                    this.tempLine.to = pos;
                    
                    // Show tooltip for station
                    const station = this.findStationAt(pos.x, pos.y);
                    const tooltip = document.getElementById('tooltip');
                    
                    if (station && station !== this.tempLine.from) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                        tooltip.innerHTML = `Connect to ${station.shape}<br>Passengers: ${station.passengers.length}/${MAX_PASSENGERS}`;
                    } else {
                        tooltip.style.display = 'none';
                    }
                }
            }
            
            handleMouseUp(e) {
                if (this.isDragging) {
                    this.isDragging = false;
                    return;
                }
                
                if (this.drawingLine && this.tempLine && this.tempLine.to) {
                    const station = this.findStationAt(this.tempLine.to.x, this.tempLine.to.y);
                    
                    if (station && station !== this.tempLine.from) {
                        this.currentLine.addStation(station);
                    }
                }
                
                this.drawingLine = false;
                this.tempLine = null;
                document.getElementById('tooltip').style.display = 'none';
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.3, Math.min(3, this.zoom * zoomFactor));
                
                // Zoom towards mouse position
                const mouseX = e.clientX;
                const mouseY = e.clientY;
                
                const worldX = (mouseX - this.offsetX) / this.zoom;
                const worldY = (mouseY - this.offsetY) / this.zoom;
                
                this.zoom = newZoom;
                
                this.offsetX = mouseX - worldX * this.zoom;
                this.offsetY = mouseY - worldY * this.zoom;
                
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
            }
            
            handleTouchStart(e) {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    this.handleMouseDown({ 
                        clientX: touch.clientX, 
                        clientY: touch.clientY, 
                        button: 0 
                    });
                } else if (e.touches.length === 2) {
                    this.isDragging = true;
                    this.dragStart = { 
                        x: (e.touches[0].clientX + e.touches[1].clientX) / 2 - this.offsetX,
                        y: (e.touches[0].clientY + e.touches[1].clientY) / 2 - this.offsetY
                    };
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
                } else if (e.touches.length === 2 && this.isDragging) {
                    this.offsetX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - this.dragStart.x;
                    this.offsetY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - this.dragStart.y;
                }
            }
            
            handleTouchEnd(e) {
                this.handleMouseUp({});
            }
            
            screenToWorld(sx, sy) {
                return {
                    x: (sx - this.offsetX) / this.zoom,
                    y: (sy - this.offsetY) / this.zoom
                };
            }
            
            worldToScreen(wx, wy) {
                return {
                    x: wx * this.zoom + this.offsetX,
                    y: wy * this.zoom + this.offsetY
                };
            }
            
            findStationAt(x, y) {
                const threshold = 30 / this.zoom;
                return this.stations.find(s => {
                    const dx = s.x - x;
                    const dy = s.y - y;
                    return Math.sqrt(dx * dx + dy * dy) < threshold;
                });
            }
            
            newGame() {
                this.stations = [];
                this.lines = [];
                this.trains = [];
                this.selectedLine = null;
                this.currentLine = null;
                this.time = 0;
                this.passengersDelivered = 0;
                this.isPaused = false;
                this.isGameOver = false;
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                
                document.getElementById('gameOver').style.display = 'none';
                
                // Create initial stations
                for (let i = 0; i < 5; i++) {
                    this.spawnStation();
                }
                
                // Reset UI
                document.querySelectorAll('.line-btn').forEach(btn => btn.classList.remove('active', 'disabled'));
            }
            
            spawnStation() {
                const margin = 100;
                const x = margin + Math.random() * (this.canvas.width - margin * 2);
                const y = margin + Math.random() * (this.canvas.height - margin * 2);
                const shape = STATION_SHAPES[Math.floor(Math.random() * 3)]; // Start with basic shapes
                
                // Ensure minimum distance from other stations
                const minDist = 100;
                const tooClose = this.stations.some(s => {
                    const dx = s.x - x;
                    const dy = s.y - y;
                    return Math.sqrt(dx * dx + dy * dy) < minDist;
                });
                
                if (!tooClose) {
                    this.stations.push(new Station(x, y, shape));
                }
            }
            
            update(dt) {
                if (this.isPaused || this.isGameOver) return;
                
                this.time += dt;
                
                // Spawn new stations periodically
                this.lastSpawn += dt;
                if (this.lastSpawn > SPAWN_INTERVAL / 1000 && this.stations.length < 15) {
                    this.spawnStation();
                    this.lastSpawn = 0;
                }
                
                // Spawn passengers
                this.lastPassenger += dt;
                if (this.lastPassenger > PASSENGER_INTERVAL / 1000) {
                    this.spawnPassengers();
                    this.lastPassenger = 0;
                }
                
                // Update trains
                this.trains.forEach(train => train.update(dt));
                
                // Check for overcrowded stations
                for (const station of this.stations) {
                    if (station.isOvercrowded()) {
                        // Give some time before game over
                        station.overcrowdedTime = (station.overcrowdedTime || 0) + dt;
                        if (station.overcrowdedTime > 10) {
                        this.gameOver();
                        return;
                        }
                    } else {
                        station.overcrowdedTime = 0;
                    }
                }
                
                // Update UI
                const minutes = Math.floor(this.time / 60);
                const seconds = Math.floor(this.time % 60);
                document.getElementById('time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('passengers').textContent = this.passengersDelivered;
                document.getElementById('linesCount').textContent = this.lines.length;
            }
            
            spawnPassengers() {
                if (this.stations.length < 2) return;
                
                // Add passenger to random station
                const station = this.stations[Math.floor(Math.random() * this.stations.length)];
                const destination = STATION_SHAPES[Math.floor(Math.random() * 3)];
                
                if (destination !== station.shape) {
                    station.addPassenger(destination);
                }
            }
            
            gameOver() {
                this.isGameOver = true;
                document.getElementById('finalScore').textContent = this.passengersDelivered;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            pause() {
                this.isPaused = !this.isPaused;
            }
            
            resetView() {
                this.zoom = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                document.getElementById('zoomLevel').textContent = '100%';
            }
            
            clearLine() {
                if (this.currentLine) {
                    this.currentLine.stations.forEach(s => s.connections.delete(this.currentLine.id));
                    this.currentLine.stations = [];
                }
            }
            
            zoomIn() {
                this.zoom = Math.min(3, this.zoom * 1.2);
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
            }
            
            zoomOut() {
                this.zoom = Math.max(0.3, this.zoom / 1.2);
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
            }
            
            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.save();
                ctx.translate(this.offsetX, this.offsetY);
                ctx.scale(this.zoom, this.zoom);
                
                // Draw grid
                this.drawGrid();
                
                // Draw lines with overlap handling
                this.drawLines();
                
                // Draw temporary line
                if (this.tempLine && this.tempLine.to) {
                    ctx.beginPath();
                    ctx.strokeStyle = this.currentLine.color;
                    ctx.lineWidth = 8;
                    ctx.setLineDash([10, 10]);
                    ctx.moveTo(this.tempLine.from.x, this.tempLine.from.y);
                    ctx.lineTo(this.tempLine.to.x, this.tempLine.to.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw stations
                this.stations.forEach(station => this.drawStation(station));
                
                // Draw trains
                this.trains.forEach(train => this.drawTrain(train));
                
                ctx.restore();
            }
            
            drawGrid() {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                
                const gridSize = 50;
                const startX = -this.offsetX / this.zoom;
                const startY = -this.offsetY / this.zoom;
                const endX = startX + this.canvas.width / this.zoom;
                const endY = startY + this.canvas.height / this.zoom;
                
                for (let x = Math.floor(startX / gridSize) * gridSize; x < endX; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                    ctx.stroke();
                }
                
                for (let y = Math.floor(startY / gridSize) * gridSize; y < endY; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                    ctx.stroke();
                }
            }
            
            drawLines() {
                const ctx = this.ctx;
                
                // Track overlap offsets
                const overlapMap = new Map();
                
                this.lines.forEach((line, lineIndex) => {
                    if (line.stations.length < 2) return;
                    
                    ctx.strokeStyle = line.color;
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    
                    for (let i = 0; i < line.stations.length - 1; i++) {
                        const from = line.stations[i];
                        const to = line.stations[i + 1];
                        
                        // Calculate offset for overlapping segments
                        const key = this.getSegmentKey(from, to);
                        let offset = 0;
                        
                        if (overlapMap.has(key)) {
                            const count = overlapMap.get(key);
                            offset = count * 12; // Offset each overlapping line
                            overlapMap.set(key, count + 1);
                        } else {
                            overlapMap.set(key, 1);
                        }
                        
                        // Calculate perpendicular offset
                        const dx = to.x - from.x;
                        const dy = to.y - from.y;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        
                        if (len > 0) {
                            const perpX = -dy / len * offset;
                            const perpY = dx / len * offset;
                            
                            if (i === 0) {
                                ctx.moveTo(from.x + perpX, from.y + perpY);
                            }
                            ctx.lineTo(to.x + perpX, to.y + perpY);
                        }
                    }
                    
                    ctx.stroke();
                    
                    // Draw line border for better visibility
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 10;
                    ctx.stroke();
                    
                    // Redraw main line
                    ctx.strokeStyle = line.color;
                    ctx.lineWidth = 8;
                    ctx.stroke();
                });
            }
            
            getSegmentKey(s1, s2) {
                const ids = [s1.id, s2.id].sort();
                return ids.join('-');
            }
            
            drawStation(station) {
                const ctx = this.ctx;
                const size = 25;
                
                // Background
                ctx.fillStyle = '#1a1a2e';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                
                // Draw shape based on type
                ctx.beginPath();
                switch (station.shape) {
                    case 'circle':
                        ctx.arc(station.x, station.y, size, 0, Math.PI * 2);
                        break;
                    case 'triangle':
                        ctx.moveTo(station.x, station.y - size);
                        ctx.lineTo(station.x + size * 0.866, station.y + size * 0.5);
                        ctx.lineTo(station.x - size * 0.866, station.y + size * 0.5);
                        ctx.closePath();
                        break;
                    case 'square':
                        ctx.rect(station.x - size * 0.8, station.y - size * 0.8, size * 1.6, size * 1.6);
                        break;
                    case 'diamond':
                        ctx.moveTo(station.x, station.y - size);
                        ctx.lineTo(station.x + size, station.y);
                        ctx.lineTo(station.x, station.y + size);
                        ctx.lineTo(station.x - size, station.y);
                        ctx.closePath();
                        break;
                    case 'pentagon':
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                            const x = station.x + size * Math.cos(angle);
                            const y = station.y + size * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        break;
                    case 'star':
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) - Math.PI / 2;
                            const r = i % 2 === 0 ? size : size * 0.5;
                            const x = station.x + r * Math.cos(angle);
                            const y = station.y + r * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        break;
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Draw passengers
                if (station.passengers.length > 0) {
                    const passengerSize = 8;
                    const cols = 4;
                    station.passengers.forEach((p, i) => {
                        const px = station.x + 35 + (i % cols) * (passengerSize + 2);
                        const py = station.y - 20 + Math.floor(i / cols) * (passengerSize + 2);
                        
                        ctx.fillStyle = this.getShapeColor(p);
                        this.drawMiniShape(px, py, p, passengerSize * 0.7);
                    });
                }
                
                // Warning for overcrowding
                if (station.isOvercrowded()) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(station.x, station.y, size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            drawMiniShape(x, y, shape, size) {
                const ctx = this.ctx;
                ctx.beginPath();
                
                switch (shape) {
                    case 'circle':
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        break;
                    case 'triangle':
                        ctx.moveTo(x, y - size);
                        ctx.lineTo(x + size * 0.866, y + size * 0.5);
                        ctx.lineTo(x - size * 0.866, y + size * 0.5);
                        ctx.closePath();
                        break;
                    case 'square':
                        ctx.rect(x - size * 0.7, y - size * 0.7, size * 1.4, size * 1.4);
                        break;
                    default:
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                }
                
                ctx.fill();
            }
            
            getShapeColor(shape) {
                const colors = {
                    circle: '#e74c3c',
                    triangle: '#3498db',
                    square: '#2ecc71',
                    diamond: '#f39c12',
                    pentagon: '#9b59b6',
                    star: '#1abc9c'
                };
                return colors[shape] || '#fff';
            }
            
            drawTrain(train) {
                const pos = train.getPosition();
                if (!pos) return;
                
                const ctx = this.ctx;
                
                // Train body
                ctx.fillStyle = train.line.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.roundRect(pos.x - 15, pos.y - 8, 30, 16, 4);
                ctx.fill();
                ctx.stroke();
                
                // Passenger indicator
                if (train.passengers.length > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(train.passengers.length.toString(), pos.x, pos.y + 4);
                }
            }
            
            animate() {
                const currentTime = performance.now();
                const dt = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                this.update(dt);
                this.draw();
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize game
        const game = new Game();
    </script>
</body>
</html>